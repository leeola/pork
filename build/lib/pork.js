// Generated by CoffeeScript 1.4.0
(function() {
  var copy, exists, exists_cascade, exists_sync, fs, home, list, list_list, make_directory, path, read_file, remove, sep, subtract, write_file,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  copy = function(fin, out, opts, callback) {
    var cb, done_check, fin_info, listing, running, scb, stream_callback, writing, _ref, _ref1, _ref2;
    if (opts == null) {
      opts = {};
    }
    if (callback == null) {
      callback = function() {};
    }
    if (opts instanceof Function) {
      stream_callback = callback;
      callback = opts;
      opts = {};
    }
    if ((_ref = opts.depth) == null) {
      opts.depth = 0;
    }
    if ((_ref1 = opts.overwrite) == null) {
      opts.overwrite = true;
    }
    if ((_ref2 = opts.merge) == null) {
      opts.merge = true;
    }
    running = true;
    listing = true;
    writing = 0;
    fin_info = void 0;
    done_check = function() {
      if (running && writing <= 0 && !listing) {
        return callback(null);
      }
    };
    cb = function() {
      listing = false;
      return done_check();
    };
    scb = function(in_path, info) {
      var dirs, out_path;
      if (!running) {
        return;
      }
      writing += 1;
      if (!(fin_info != null)) {
        fin_info = info;
      }
      if (!opts.merge) {
        out_path = path.join(out, in_path);
      } else if (!fin_info.isfile) {
        dirs = in_path.split(sep());
        dirs[0] = out;
        out_path = dirs.join(sep());
      } else {
        out_path = out;
      }
      if (info.isfile) {
        return make_directory(path.dirname(out_path), function(err) {
          if ((err != null) && err.message !== 'Directory already exists') {
            running = false;
            callback(err);
            return;
          }
          return read_file(in_path, function(err, data) {
            if (err != null) {
              running = false;
              callback(err);
              return;
            }
            return write_file(out_path, data, {
              overwrite: opts.overwrite
            }, function(err) {
              if (err != null) {
                running = false;
                callback(err);
                return;
              }
              writing -= 1;
              return done_check();
            });
          });
        });
      } else {
        writing -= 1;
        return done_check();
      }
    };
    return list(fin, {
      depth: opts.depth
    }, cb, scb);
  };

  exists = fs.exists != null ? fs.exists : path.exists;

  exists_sync = fs.existsSync != null ? fs.existsSync : path.existsSync;

  exists_cascade = function(file, callback) {
    var cwd, exists_cb, results;
    if (callback == null) {
      callback = function() {};
    }
    cwd = file;
    results = [];
    exists_cb = function(result) {
      results.push([result, cwd]);
      if (result) {
        if (results.length === 1) {
          return callback(true, results, true);
        } else {
          return callback(false, results, true);
        }
      } else {
        cwd = path.dirname(cwd);
        if (cwd === '.' && file.slice(0, 2) !== ("." + (sep()))) {
          return callback(false, results, false);
        } else {
          return exists(cwd, exists_cb);
        }
      }
    };
    return exists(file, exists_cb);
  };

  home = function() {
    switch (process.platform) {
      case 'win32':
        return process.env.USERPROFILE;
      case 'linux':
        return process.env.HOME;
      default:
        return process.env.HOME || process.env.USERPROFILE;
    }
  };

  list_list = function(source_list, opts, callback, streaming_callback) {
    var cb, infos, item, iter, list_copy, list_len, listed, running, scb;
    list_copy = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = source_list.length; _i < _len; _i++) {
        item = source_list[_i];
        _results.push(item);
      }
      return _results;
    })();
    list_len = source_list.length;
    listed = 0;
    running = true;
    infos = [];
    cb = function(err, info) {
      if (!running) {
        return;
      }
      if (err != null) {
        running = false;
        callback(err);
        return;
      }
      infos.concat(info);
      listed++;
      if (listed === list_len) {
        running = false;
        return callback(null, infos);
      }
    };
    scb = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (running) {
        return streaming_callback.apply(null, args);
      }
    };
    iter = function() {
      item = list_copy.pop();
      if (!(item != null)) {
        return;
      }
      list(item, opts, cb, scb);
      return iter();
    };
    return iter();
  };

  list = function(base, opts, callback, streaming_callback) {
    var fmt, rel, rlist, _ref;
    if (opts == null) {
      opts = {};
    }
    if (callback == null) {
      callback = (function() {});
    }
    if (streaming_callback == null) {
      streaming_callback = function() {};
    }
    if (opts instanceof Function) {
      streaming_callback = callback;
      callback = opts;
      opts = {};
    }
    if ((_ref = opts.depth) == null) {
      opts.depth = 1;
    }
    rel = '';
    if (base instanceof Array) {
      list_list(base, opts, callback, streaming_callback);
      return;
    }
    fmt = function(rel, file) {
      if (rel === base) {
        return {
          base: base,
          rel: '',
          file: file
        };
      } else if (base === path.join(rel, file)) {
        return {
          base: base,
          rel: '',
          file: ''
        };
      } else {
        return {
          base: base,
          rel: subtract(base, rel),
          file: file
        };
      }
    };
    rlist = function(rel, file, depth, cb) {
      var src;
      src = path.join(rel, file);
      return fs.stat(src, function(err, stat) {
        var info;
        if (err != null) {
          return cb(err, null);
        }
        info = fmt(rel, file);
        info.path = src;
        info.isfile = stat.isFile();
        info.stat = stat;
        streaming_callback(src, info);
        if (info.isfile) {
          cb(null, [info]);
        } else if (depth >= opts.depth && opts.depth > 0) {
          cb(null, [info]);
        } else {
          return fs.readdir(src, function(err, files) {
            var cb_count, file_infos, running, _i, _len, _results;
            file_infos = [info];
            if (files.length === 0) {
              cb(null, file_infos);
              return;
            }
            rel = src;
            cb_count = 0;
            running = true;
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              file = files[_i];
              _results.push(rlist(rel, file, depth + 1, function(err, fi) {
                if (!running) {
                  return;
                }
                if (err != null) {
                  cb(err, null);
                  running = false;
                  return;
                }
                cb_count += 1;
                file_infos = file_infos.concat(fi);
                if (cb_count >= files.length) {
                  cb(null, file_infos);
                }
              }));
            }
            return _results;
          });
        }
      });
    };
    return rlist(base, '', 0, function(err, file_infos) {
      return callback(err, file_infos);
    });
  };

  make_directory = function(dir, opts, callback) {
    var mkdir_cascade, _ref, _ref1;
    if (opts == null) {
      opts = {};
    }
    if (callback == null) {
      callback = function() {};
    }
    if (opts instanceof Function) {
      callback = opts;
      opts = {};
    }
    if ((_ref = opts.cascade) == null) {
      opts.cascade = true;
    }
    if ((_ref1 = opts.mode) == null) {
      opts.mode = void 0;
    }
    if (opts.cascade) {
      mkdir_cascade = function(cascade) {
        var cascade_item, dir_exists;
        cascade_item = cascade.pop();
        if (!(cascade_item != null)) {
          return callback(null);
        }
        dir_exists = cascade_item[0], dir = cascade_item[1];
        if (dir_exists) {
          return mkdir_cascade(cascade);
        }
        return fs.mkdir(dir, opts.mode, function(err) {
          if (err != null) {
            if (err.message.slice(0, 13) === 'EEXIST, mkdir') {
              return callback(new Error('Directory already exists'));
            }
            return callback(err);
          }
          return mkdir_cascade(cascade);
        });
      };
      return exists_cascade(dir, function(exists, cascade, root_exists) {
        if (exists) {
          return callback(new Error('Directory already exists'));
        } else {
          return mkdir_cascade(cascade);
        }
      });
    } else {
      return fs.mkdir(dir, opts.mode, function(err) {
        if (err != null) {
          if (err.message.slice(0, 13) === 'EEXIST, mkdir') {
            return callback(new Error('Directory already exists'));
          }
          return callback(err);
        }
        return callback(null);
      });
    }
  };

  read_file = fs.readFile;

  remove = function(rm_path, opts, callback) {
    var dirs_cb, fcount, file_done_check, files_cb, files_stream, listing, running, _ref;
    if (opts == null) {
      opts = {};
    }
    if (callback == null) {
      callback = function() {};
    }
    if (opts instanceof Function) {
      callback = opts;
      opts = {};
    }
    if ((_ref = opts.depth) == null) {
      opts.depth = 1;
    }
    fcount = 0;
    listing = true;
    running = true;
    dirs_cb = function(err, infos) {
      var rm_dirs;
      if (!running) {
        return;
      }
      if (err != null) {
        running = false;
        callback(err);
        return;
      }
      rm_dirs = function() {
        var dir_info;
        dir_info = infos.pop();
        if (!(dir_info != null)) {
          return callback(null);
        }
        if (dir_info.isfile) {
          running = false;
          return callback(new Error("Unable to remove file '" + dir_info.path + "'"));
        } else {
          return fs.rmdir(dir_info.path, function(err) {
            if (err != null) {
              running = false;
              callback(err);
              return;
            }
            return rm_dirs();
          });
        }
      };
      return rm_dirs();
    };
    file_done_check = function() {
      if (!running) {
        return;
      }
      if (!listing && fcount === 0) {
        return list(rm_path, {
          depth: opts.depth
        }, dirs_cb);
      }
    };
    files_cb = function(err) {
      if (!running) {
        return;
      }
      if (err != null) {
        running = false;
        callback(err);
        return;
      }
      listing = false;
      return file_done_check();
    };
    files_stream = function(file_path, info) {
      if (info.isfile) {
        fcount += 1;
        return fs.unlink(file_path, function(err) {
          if (err != null) {
            running = false;
            callback(err);
            return;
          }
          fcount -= 1;
          return file_done_check();
        });
      } else {
        return file_done_check();
      }
    };
    return list(rm_path, {
      depth: opts.depth
    }, files_cb, files_stream);
  };

  sep = function() {
    if (path.sep) {
      return path.sep;
    } else {
      return path.join('a', 'b')[1];
    }
  };

  subtract = function(a, b) {
    var i, j, split, _i, _len;
    split = function(path) {
      var r;
      r = path.split(sep());
      if (r[0] === '') {
        r.splice(0, 1);
        r[0] = sep() + r[0];
      }
      return r;
    };
    a = split(a);
    b = split(b);
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      j = a[i];
      if (j !== b[i]) {
        break;
      }
    }
    return b.slice(i).join(sep());
  };

  write_file = function(file, data, opts, callback) {
    var dir, _ref, _ref1;
    if (callback == null) {
      callback = function() {};
    }
    if (opts instanceof Function) {
      callback = opts;
      opts = {};
    }
    if ((_ref = opts.encoding) == null) {
      opts.encoding = void 0;
    }
    if ((_ref1 = opts.parents) == null) {
      opts.parents = true;
    }
    dir = path.dirname(file);
    return exists(dir, function(dir_exists) {
      if (dir_exists) {
        return fs.writeFile(file, data, opts.encoding, callback);
      } else if (opts.parents) {
        return make_directory(dir, {
          cascade: true
        }, function(err) {
          if (err != null) {
            return callback(err);
          }
          return fs.writeFile(file, data, opts.encoding, callback);
        });
      } else {
        return callback(new Error('Directory does not exist'));
      }
    });
  };

  exports.copy = copy;

  exports.exists = exists;

  exports.exists_cascade = exists_cascade;

  exports.exists_sync = exists_sync;

  exports.__defineGetter__('home', home);

  exports.list = list;

  exports.make_directory = make_directory;

  exports.__defineGetter__('sep', sep);

  exports.read_file = read_file;

  exports.remove = remove;

  exports.subtract = subtract;

  exports.write_file = write_file;

}).call(this);
