// Generated by CoffeeScript 1.3.3
(function() {
  var copy, exists, exists_cascade, fs, home, list, make_directory, move, path, path_join, read_file, recursive_list, relative_list, remove, sep, write_file;

  fs = require('fs');

  path = require('path');

  path_join = path.join;

  copy = function() {
    throw new Error('Not Implemented');
  };

  exists = fs.exists != null ? fs.exists : path.exists;

  exists_cascade = function(file, callback) {
    var cwd, exists_callback, results;
    if (callback == null) {
      callback = function() {};
    }
    cwd = file;
    results = [];
    exists_callback = function(exist_result) {
      results.push([exist_result, cwd]);
      if (exist_result) {
        if (results.length === 1) {
          return callback(true, results, true);
        } else {
          return callback(false, results, true);
        }
      } else {
        cwd = path.dirname(cwd);
        if (cwd === '.' && file.slice(0, 2) !== '.' + sep()) {
          callback(false, results, false);
        } else {
          return exists(cwd, exists_callback);
        }
      }
    };
    return exists(file, exists_callback);
  };

  home = function() {
    switch (process.platform) {
      case 'win32':
        return process.env.USERPROFILE;
      case 'linux':
        return process.env.HOME;
      default:
        return process.env.HOME || process.env.USERPROFILE;
    }
  };

  list = function(source, recursive, callback, stream) {
    if (source == null) {
      source = '';
    }
    if (recursive == null) {
      recursive = false;
    }
    if (recursive) {
      return recursive_list(source, '', '', callback, stream);
    } else {
      return relative_list(source, '', '', callback, stream);
    }
  };

  make_directory = function(dir, mode, callback) {
    var mkdir_cascade;
    if (mode instanceof Function) {
      callback = mode;
      mode = void 0;
    }
    exists_cascade(dir, function(exists, cascade) {
      if (exists) {
        callback(new Error('Directory already exists.'));
        return;
      }
      return mkdir_cascade(cascade);
    });
    return mkdir_cascade = function(cascade) {
      var cascade_item;
      if (cascade == null) {
        cascade = [];
      }
      cascade_item = cascade.pop();
      if (!(cascade_item != null)) {
        callback(null);
        return;
      }
      exists = cascade_item[0], dir = cascade_item[1];
      if (exists) {
        mkdir_cascade(cascade);
        return;
      }
      return fs.mkdir(dir, mode, function(err) {
        if (err) {
          callback(err);
          return;
        }
        return mkdir_cascade(cascade);
      });
    };
  };

  move = function() {
    throw new Error('Not Implemented');
  };

  read_file = fs.readFile;

  recursive_list = function(base, rel, file, callback, stream) {
    var depth, results, single_callback, single_stream;
    results = [];
    depth = 0;
    single_callback = function(err, single_results) {
      results.push.apply(results, single_results);
      if (depth === 0) {
        return callback(null, results);
      } else {
        return depth--;
      }
    };
    single_stream = function(base, rel, file, stats) {
      stream(base, rel, file, stats);
      if (stats.isDirectory()) {
        depth++;
        return relative_list(base, rel, file, single_callback, single_stream);
      }
    };
    return relative_list(base, rel, file, single_callback, single_stream);
  };

  relative_list = function(base, rel, file, callback, stream) {
    var source;
    source = path_join(base, rel, file);
    return fs.stat(source, function(err, stats) {
      var file_count, file_results;
      if (err != null) {
        callback(err);
        return;
      }
      if (stats.isFile()) {
        if (file === '') {
          file = path.basename(source);
          if (rel.slice(-file.length) === file) {
            rel = rel.slice(0, (file.length + 1) + 1 || 9e9);
          } else {
            base = base.slice(0, (file.length + 1) + 1 || 9e9);
          }
        }
        stream(base, rel, file, stats);
        callback(null, [[base, rel, file, stats]]);
      } else {
        file_count = 0;
        file_results = [];
        return fs.readdir(source, function(err, files) {
          var stats_closure, total_files, _i, _len, _results;
          if (err) {
            callback(err);
            return;
          }
          total_files = files.length;
          if (total_files === 0) {
            callback(null, []);
            return;
          } else {
            rel = path_join(rel, file);
            if (rel === '.') {
              rel = '';
            }
          }
          stats_closure = function(base, rel, file) {
            source = path.join(base, rel, file);
            return fs.stat(source, function(err, stats) {
              if (err) {
                callback(err);
              }
              stream(base, rel, file, stats);
              file_results.push([base, rel, file, stats]);
              file_count++;
              if (file_count === total_files) {
                return callback(null, file_results);
              }
            });
          };
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results.push(stats_closure(base, rel, file));
          }
          return _results;
        });
      }
    });
  };

  remove = function() {
    throw new Error('Not Implemented');
  };

  sep = function() {
    if (path.sep) {
      return path.sep;
    } else {
      return path.join('a', 'b')[1];
    }
  };

  write_file = function(file, data, encoding, callback) {
    var dir;
    if (callback == null) {
      callback = function() {};
    }
    dir = path.dirname(file);
    return exists(dir, function(dir_exists) {
      if (!dir_exists) {
        return make_directory(dir, function(err) {
          if (err) {
            throw err;
          }
          return fs.writeFile(file, data, encoding, callback);
        });
      } else {
        return fs.writeFile(file, data, encoding, callback);
      }
    });
  };

  exports.copy = copy;

  exports.exists = exists;

  exports.exists_cascade = exists_cascade;

  exports.home = home;

  exports.list = list;

  exports.recursive_list = recursive_list;

  exports.relative_list = relative_list;

  exports.make_directory = make_directory;

  exports.remove = remove;

  exports.sep = sep;

  exports.write_file = write_file;

}).call(this);
